
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor.PackageManager;
using UnityEngine;


public class Plan
{
    public Blob SourceBlob { get; set; }
    public Blob TargetBlob { get; set; }
    public Dictionary<Blob, BlobSize> SizeChanges { get; set; } = new();
    public Action<Plan> OnMergeComplete;
    public Vector2Int StartPosition { get; set; }
    public Vector2Int EndPosition { get; set; }
    public Vector2Int Direction { get; set; }
    public List<Blob> BlobsToRemoveDuringMerge { get; set; } = new();
    public List<Blob> BlobsToCreateDuringMerge { get; set; } = new();
    public List<Blob> BlobsToRemoveAfterMerge { get; set; } = new();
    public List<Blob> BlobsToCreateAfterMerge { get; set; } = new();


    public static Plan operator -(Plan plan) => new()
    {
        StartPosition = plan.EndPosition,
        EndPosition = plan.StartPosition,
        Direction = -plan.Direction,
        TargetBlob = plan?.TargetBlob,
        SourceBlob = plan.SourceBlob,
        OnMergeComplete = plan.OnMergeComplete,
        BlobsToCreateDuringMerge = plan.BlobsToRemoveDuringMerge,
        BlobsToRemoveDuringMerge = plan.BlobsToCreateDuringMerge,

    };
    public int GetMoveCount()
    {
        return (int)Vector2Int.Distance(StartPosition, EndPosition);

    }
}

/// <summary>
/// A data-only class that describes all the actions that will occur
/// during a valid merge. This is generated by BoardLogic and used by
/// BoardPresenter to build the command.
/// </summary>
public class MergePlan : Plan
{




    //Secondary merge plan that will happen after the first merge action
    public Plan DeferredPlan { get; set; }

    public bool ShouldTerminate { get; set; }


    public static MergePlan operator -(MergePlan plan) => new()
    {
        StartPosition = plan.EndPosition,
        EndPosition = plan.StartPosition,
        Direction = -plan.Direction,
        TargetBlob = plan?.TargetBlob,
        SourceBlob = plan.SourceBlob,
        OnMergeComplete = plan.OnMergeComplete,
        BlobsToCreateDuringMerge = plan.BlobsToRemoveDuringMerge,
        BlobsToRemoveAfterMerge = plan.BlobsToCreateAfterMerge,
        BlobsToCreateAfterMerge = plan.BlobsToRemoveAfterMerge,
        BlobsToRemoveDuringMerge = plan.BlobsToCreateDuringMerge,
        DeferredPlan = plan.DeferredPlan != null ? -plan.DeferredPlan : null

    };
    public override string ToString()
    {
        string str = "";
        str += "Start position: " + StartPosition;
        str += "End position: " + EndPosition;
        str += "Source Blob: " + SourceBlob;
        str += "Target Blob: " + TargetBlob;
        str += "Direction: " + Direction;

        return str;
    }
    
}
public class BoardLogic
{
    private readonly Dictionary<string, Blob> _blobsById;
    private readonly Dictionary<string, Tile> _tilesById;

    public Blob[,] BlobGrid { get; private set; }
    public Tile[,] TileGrid { get; private set; }

    public int Width { get; private set; }
    public int Height { get; private set; }
    // Events for the Presenter to subscribe to.
    // These events are the ONLY way the logic communicates with the outside world.
    public static event Action<Blob> OnBlobCreated;
    public static event Action<Tile> OnTileCreated;
    public static event Action<Blob, Vector2Int, Vector2Int> OnBlobMoved; // ID, From, To
    public List<Blob> GetAllBlobs() =>_blobsById.Values.ToList();
    public List<Tile> GetAllTiles() => _tilesById.Values.ToList();
    public int BlobCount => _blobsById.Count;

    public static event Action<Blob> OnBlobRemoved;
    public static event Action OnBoardCleared;
    public static event Action<BoardLogic> OnBoardCreated;

    public BoardLogic(int width, int height)
    {
        Width = width;
        Height = height;
        _blobsById = new Dictionary<string, Blob>();
        _tilesById = new Dictionary<string, Tile>();

    }
    
    // Called by the Presenter to start a level.
    public void CreateInitialBoard(List<Blob> blobs, List<Tile> tiles)
    {
        BlobGrid = new Blob[Width, Height];
        TileGrid = new Tile[Width, Height];

        _blobsById.Clear();
        foreach (var blobData in blobs)
        {
            PlaceBlob(blobData);
        }
        foreach (var tileData in tiles)
        {
            PlaceTile(tileData);
        }

        OnBoardCreated?.Invoke(this);
    }
    private bool IsLaserBlocking(Blob blob, Vector2Int sourcePosition)
    {
        List<LaserTile> lasersInColumn = FindObjectsInColumn<LaserTile>(sourcePosition.x);
        List<LaserTile> lasersInRow = FindObjectsInRow<LaserTile>(sourcePosition.y);
        foreach (LaserTile laser in lasersInColumn)
        {

            if (laser.IsActive)
            {
                if (laser.LaserColor == blob.Color)
                {

                    if (IsBetweenTiles(sourcePosition, laser.GridPosition, laser.LinkedLaser.GridPosition, laser.Direction))
                    {
                        return true;
                    }
                  
                }
            }

        }

        foreach (LaserTile laser in lasersInRow)
        {
            if (laser.IsActive)
            {
                if (laser.LaserColor == blob.Color)
                {
                    if (IsBetweenTiles(sourcePosition, laser.GridPosition, laser.LinkedLaser.GridPosition, laser.Direction))
                    {
                        return true;
                    }
                }
            }

        }
        return false;
        
    }
    public void LinkLasers(LevelData level)
    {
        foreach (var link in level.laserLinks)
        {
            if (_tilesById.TryGetValue(link.idA, out Tile tileA) &&
                _tilesById.TryGetValue(link.idB, out Tile tileB) &&
                tileA is LaserTile laserA &&
                tileB is LaserTile laserB)
            {
                laserA.LinkedLaserId = link.idB;
                laserB.LinkedLaserId = link.idA;
                laserA.LinkedLaser = laserB;
                laserB.LinkedLaser = laserA;
            }
            else
            {
                Debug.LogWarning($"Invalid laser link between {link.idA} and {link.idB}");
            }
        }
    }
private bool IsBetweenTiles(Vector2Int sourcePosition, Vector2Int from, Vector2Int to, Vector2Int direction)
    {
        // Horizontal beam
        if (direction == Vector2Int.right || direction == Vector2Int.left)
        {
            if (from.y != sourcePosition.y || to.y != sourcePosition.y)
                return false; // Not on same row

            int minX = Mathf.Min(from.x, to.x);
            int maxX = Mathf.Max(from.x, to.x);

            // Is laser beam position between the two x positions?
            return sourcePosition.x > minX && sourcePosition.x < maxX;
        }

        // Vertical beam
        if (direction == Vector2Int.up || direction == Vector2Int.down)
        {
            if (from.x != sourcePosition.x || to.x != sourcePosition.x)
                return false; // Not on same column

            int minY = Mathf.Min(from.y, to.y);
            int maxY = Mathf.Max(from.y, to.y);

            // Is laser beam position between the two y positions?
            return sourcePosition.y > minY && sourcePosition.y < maxY;
        }

        return false;
    }
    private void PlaceTile(Tile tileData)
    {
        if (tileData.GridPosition.x < 0 || tileData.GridPosition.x >= Width ||
            tileData.GridPosition.y < 0 || tileData.GridPosition.y >= Height)
        {
            Debug.LogError($"Attempted to place blob outside board bounds: {tileData.GridPosition}");
            return;
        }
        if (TileGrid[tileData.GridPosition.x, tileData.GridPosition.y] != null)
        {
            throw new ArgumentException("A tile already exists at this position: " + tileData.GridPosition);
        }

        _tilesById.Add(tileData.ID, tileData);
        TileGrid[tileData.GridPosition.x, tileData.GridPosition.y] = tileData; // Place in grid
        OnTileCreated?.Invoke(tileData);
    }

    public void PlaceBlob(Blob blob)
    {
        if (blob.GridPosition.x < 0 || blob.GridPosition.x >= Width ||
            blob.GridPosition.y < 0 || blob.GridPosition.y >= Height)
        {
            Debug.LogError($"Attempted to place blob outside board bounds: {blob.GridPosition}");
            return;
        }
        

        if (_blobsById.TryAdd(blob.ID, blob))
        {
            BlobGrid[blob.GridPosition.x, blob.GridPosition.y] = blob; 
            OnBlobCreated?.Invoke(blob); 
            
        }
       
        
    }
    public MergePlan CalculateMergePlan(Blob sourceBlob, Blob targetBlob)
    {       

        if (!CheckMerge(sourceBlob.ID, targetBlob.ID)) return null;
       
        Vector2Int direction = targetBlob.GridPosition - sourceBlob.GridPosition;
        direction.Clamp(new Vector2Int(-1, -1), new Vector2Int(1, 1));
        // --- Base Plan Calculation ---
        var plan = new MergePlan
        {
            SourceBlob = sourceBlob,
            TargetBlob = targetBlob,
            StartPosition = sourceBlob.GridPosition,
            Direction = direction,

        };
      
        Vector2Int currentPos = sourceBlob.GridPosition + direction;
        //traverse the path to iterativley modify the plan from the source and target blobs
        while (currentPos != targetBlob.GridPosition + direction)
        {

            Blob blobOnPath = BlobGrid[currentPos.x, currentPos.y];
            Tile tileOnPath = TileGrid[currentPos.x, currentPos.y];

            if (tileOnPath == null || !tileOnPath.TileType.IsTraversable()) return null;

            else if (blobOnPath != null && !CheckMerge(sourceBlob.ID, blobOnPath.ID)) return null; // Invalid path
            else if (IsLaserBlocking(sourceBlob, currentPos)) return null;

            plan.TargetBlob = blobOnPath;
            plan.EndPosition = currentPos;
            
            sourceBlob.Behavior.ModifyMergeFromSource(plan, this);
            blobOnPath?.Behavior.ModifyMergeFromTarget(plan, this);
            tileOnPath?.Behavior.ModifyMerge(plan, this);
            if (plan.ShouldTerminate)
            {
                break;
            }


            currentPos += direction;


        }
        // --- End of Base Plan Calculation ---
        
        if (!targetBlob.CanMergeWith(sourceBlob, plan, this)) return null;

        return plan;
    }
    public void RemoveBlob(Blob blob)
    {
        if (_blobsById.TryGetValue(blob.ID, out Blob blobToRemove))
        {
            _blobsById.Remove(blob.ID);
            BlobGrid[blobToRemove.GridPosition.x, blobToRemove.GridPosition.y] = null;
            OnBlobRemoved?.Invoke(blobToRemove);
        }
    }

    public void MoveBlob(Blob blob, Vector2Int toPosition)
    {
        if (_blobsById.TryGetValue(blob.ID, out Blob blobToMove))
        {
            Vector2Int fromPosition = blobToMove.GridPosition;
            BlobGrid[fromPosition.x, fromPosition.y] = null;
            BlobGrid[toPosition.x, toPosition.y] = blobToMove;
            blob.GridPosition = toPosition;
            OnBlobMoved?.Invoke(blob, fromPosition, toPosition);
        }
    }
    public Blob GetBlob(string id)
    {
        _blobsById.TryGetValue(id, out var blob);
        return blob;
    }
     public Tile GetTile(string id)
    {
        _tilesById.TryGetValue(id, out var tile);
        return tile;
    }
   
    public Blob GetBlobAt(Vector2Int position)
    {
        if (position.x >= 0 && position.x < Width && position.y >= 0 && position.y < Height)
        {
            return BlobGrid[position.x, position.y];
        }
        return null;
    }
    
    public T GetBlobAt<T>(Vector2Int position)
    {
        if (position.x >= 0 && position.x < Width && position.y >= 0 && position.y < Height)
        {
            if (BlobGrid[position.x, position.y] is T t)
                return t;
            else
                return default;
        }
        return default;
    }

     public T GetTileAt<T>(Vector2Int position)
    {
        if (position.x >= 0 && position.x < Width && position.y >= 0 && position.y < Height)
        {
            if (TileGrid[position.x, position.y] is T t)
                return t;
            else
                return default;
        }
        return default;
    }
   public List<T> FindObjectsInRow<T>(int row)
    {
        List<T> objects = new();
        if (row < 0 || row >= Height)
        {
           return new();


        }
        for (int col = 0; col < TileGrid.GetLength(0); col++)
        {
            if (TileGrid[col, row] is T tile)
            {
                objects.Add(tile);
            }
            if (BlobGrid[col, row] is T blob)
            {
                objects.Add(blob);
            }

        }
        return objects;

    }
    public List<T> FindObjectsInColumn<T>(int col)
    {
        List<T> objects = new();
        if (col < 0 || col >= Width)
        {
            return new();


        }
        for (int row = 0; row < TileGrid.GetLength(1); row++) 
        
        {
            if (TileGrid[col, row] is T tile)
            {
                objects.Add(tile);
            }
            if (BlobGrid[col, row] is T blob)
            {
                objects.Add(blob);
            }

        }
        return objects;

    }
    public Blob GetBlobAt(int x, int y)
    {
        if (x >= 0 && x < Width && y >= 0 && y < Height)
        {
            return BlobGrid[x, y];
        }
        return null;
    }
    public Tile GetTileAt(Vector2Int position)
    {
        if (position.x >= 0 && position.x < Width && position.y >= 0 && position.y < Height)
        {
            return TileGrid[position.x, position.y];
        }
        return null;
    }
    public Tile GetTileAt(int x, int y)
    {
        if (x >= 0 && y < Width && y >= 0 && y < Height)
        {
            return TileGrid[x, y];
        }
        return null;
    }
    
    // The core game logic method.
    public bool CheckMerge(string sourceId, string targetId)
    {
        if (!_blobsById.ContainsKey(sourceId) || !_blobsById.ContainsKey(targetId)) return false;
        
        Blob sourceBlob = _blobsById[sourceId];
        Blob targetBlob = _blobsById[targetId];
        
        //can't merge the source blob on itself
        if (sourceId == targetId) return false;
        //if the source blob is not mergable then this is invalid
        if (sourceBlob.GridPosition.x != targetBlob.GridPosition.x &&
            sourceBlob.GridPosition.y != targetBlob.GridPosition.y) return false;


            
        return true;
    }

   

   
}

